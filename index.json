[{"content":"LC26. Remove Duplicates from Sorted Array Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Example 1: Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). class Solution(object): def removeDuplicates(self, nums): slow = 0 fast = 0 while fast \u0026lt; len(nums): if nums[slow] != nums[fast]: slow +=1 nums[slow] = nums[fast] fast += 1 return slow + 1 LC27.¬†Remove Element Given an integer array¬†nums¬†and an integer¬†val, remove all occurrences of¬†val¬†in¬†nums¬†in-place. The order of the elements may be changed. Then return¬†the number of elements in¬†nums¬†which are not equal to¬†val. Consider the number of elements in¬†nums¬†which are not equal to¬†val¬†be¬†k, to get accepted, you need to do the following things: * Change the array¬†nums¬†such that the first¬†k¬†elements of¬†nums¬†contain the elements which are not equal to¬†val. The remaining elements of¬†nums¬†are not important as well as the size of¬†nums. * Return¬†k. Example 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). class Solution(object): def removeElement(self, nums, val): fast = 0 slow = 0 while fast \u0026lt; len(nums): if nums[fast] != val: nums[slow] = nums[fast] slow += 1 fast += 1 return slow LC36. Valid Sudoku Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. Example 1: Input: board = [[\u0026#34;5\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;] ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;] ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] Output: true Example 2: Input: board = [[\u0026#34;8\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;] ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;] ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8\u0026#39;s in the top left 3x3 sub-box, it is invalid. class Solution(object): def isValidSudoku(self, board): row_d = collections.defaultdict(set) col_d = collections.defaultdict(set) sqr_d = collections.defaultdict(set) for r in range(9): for c in range(9): if board[r][c] != \u0026#34;.\u0026#34;: num = board[r][c] if (num in row_d[r] or num in col_d[c] or num in sqr_d[(r//3,c//3)]): return False row_d[r].add(num) col_d[c].add(num) sqr_d[(r//3,c//3)].add(num) return True LC49. Group Anagrams Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;,\u0026#34;tan\u0026#34;,\u0026#34;ate\u0026#34;,\u0026#34;nat\u0026#34;,\u0026#34;bat\u0026#34;] Output: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] Example 2: Input: strs = [\u0026#34;\u0026#34;] Output: [[\u0026#34;\u0026#34;]] Example 3: Input: strs = [\u0026#34;a\u0026#34;] Output: [[\u0026#34;a\u0026#34;]] class Solution(object): def groupAnagrams(self, strs): hashmap = dict() for word in strs: atoz = [0 for i in range(26)] for c in word: atoz[ord(c) - ord(\u0026#34;a\u0026#34;)] += 1 tuple_atoz = tuple(atoz) hashmap[tuple_atoz] = hashmap.get(tuple_atoz,[]) + [word] return hashmap.values() LC83.¬†Remove Duplicates from Sorted List Given the¬†head¬†of a sorted linked list,¬†delete all duplicates such that each element appears only once. Return¬†the linked list¬†sorted¬†as well. Example 1: Input: head = [1,1,2] Output: [1,2] Example 2: Input: head = [1,1,2,3,3] Output: [1,2,3] class Solution(object): def deleteDuplicates(self, head): if head == None: return head now = head while now.next != None: if now.val == now.next.val: now.next = now.next.next else: now = now.next return head LC128. Longest Consecutive Sequence Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 class Solution(object): def longestConsecutive(self, nums): numset = set(nums) max_len = 0 for num in nums: if num - 1 not in numset: lenth = 1 while num + lenth in numset: lenth += 1 max_len = max(max_len, lenth) return max_len LC167.¬†Two Sum II - Input Array Is Sorted Given a¬†1-indexed¬†array of integers¬†numbers¬†that is already¬†sorted in non-decreasing order, find two numbers such that they add up to a specific¬†target¬†number. Let these two numbers be¬†numbers [index1]¬†and¬†numbers[index2]¬†where¬†1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;¬†numbers.length. Return¬†the indices of the two numbers,¬†index1¬†and¬†index2,¬†added by one¬†as an integer array¬†[index1, index2]¬†of length 2. The tests are generated such that there is¬†exactly one solution. You¬†may not¬†use the same element twice. Your solution must use only constant extra space. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. class Solution(object): def twoSum(self, numbers, target): left = 0 right = len(numbers) - 1 while left \u0026lt; right: s = numbers[left] + numbers[right] if s == target: return [left + 1, right + 1] elif s \u0026gt; target: right -= 1 else: left += 1 LC217. Contains Duplicate Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true class Solution(object): def containsDuplicate(self, nums): s = set() for num in nums: if num in s: return True s.add(num) return False LC238. Product of Array Except Self Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] class Solution(object): def productExceptSelf(self, nums): lens = len(nums) forwd = [nums[0] for i in range(lens)] backwd = [nums[-1] for i in range(lens)] i = 1 while i \u0026lt; lens: forwd[i] = forwd[i - 1] * nums[i] backwd[lens - i - 1] = backwd[lens - i] * nums[lens - i - 1] i += 1 result = [backwd[1] for i in range(lens)] result[-1] = forwd[-2] i = 1 while i \u0026lt; lens - 1: result[i] = forwd[i - 1] * backwd[i + 1] i += 1 return result LC242. Valid Anagram Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2: Input: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false class Solution(object): def isAnagram(self, s, t): if len(s) != len(t): return False s_dict, t_dict = dict(), dict() for i in range(len(s)): s_dict[s[i]] = s_dict.get(s[i], 0) + 1 t_dict[t[i]] = t_dict.get(t[i], 0) + 1 return s_dict == t_dict LC283.¬†Move Zeroes Given an integer array¬†nums, move all¬†0\u0026#39;s to the end of it while maintaining the relative order of the non-zero elements. Note¬†that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] class Solution(object): def moveZeroes(self, nums): fast = 0 slow = 0 while fast \u0026lt; len(nums): if nums[fast] != 0: nums[slow] = nums[fast] slow += 1 fast += 1 while slow \u0026lt; len(nums): nums[slow] = 0 slow += 1 return nums LC303.¬†Range Sum Query - Immutable Given an integer array¬†nums, handle multiple queries of the following type: * Calculate the¬†sum¬†of the elements of¬†nums¬†between indices¬†left¬†and¬†right¬†inclusive¬†where left \u0026lt;= right. Example 1: [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3 class NumArray(object): def __init__(self, nums): presum = nums + [0] s = 0 temp = 0 i = 0 while i \u0026lt; len(presum): temp = presum[i] presum[i] = s s += temp i += 1 self.presum = presum def sumRange(self, left, right): return self.presum[right + 1] - self.presum[left] LC344.¬†Reverse String Write a function that reverses a string. The input string is given as an array of characters¬†s. You must do this by modifying the input array¬†in-place¬†with¬†O(1)¬†extra memory. Example 1: Input: s = [\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] Example 2: Input: s = [\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] Output: [\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] class Solution(object): def reverseString(self, s): left = 0 right = len(s)-1 while left \u0026lt;= right: temp = s[left] s[left] = s[right] s[right] = temp left += 1 right -= 1 return s LC347. Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] class Solution(object): def topKFrequent(self, nums, k): num_dict = dict() for num in nums: num_dict[num] = num_dict.get(num, 0) + 1 counts_array = [[] for i in range(len(nums))] for num in num_dict: counts_array[num_dict[num]-1] += [num] i = len(nums) - 1 result = [] while k \u0026gt; 0: if counts_array[i] != []: result += counts_array[i] k -= len(counts_array[i]) i -= 1 return result ","permalink":"https://zhengshutao.github.io/posts/lc_array/","summary":"LC26. Remove Duplicates from Sorted Array Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Example 1: Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2","title":"LeetCode - Array"},{"content":" LC104. Maximum Depth of Binary Tree Given the root of a binary tree, return its maximum depth. A binary tree\u0026#39;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 class Solution(object): def maxDepth(self, root): if root == None: return 0 else: return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right)) LC116. Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with \u0026#39;#\u0026#39; signifying the end of each level. Example 2: Input: root = [] Output: [] class Solution(object): def connect(self, root): if root == None: return None def connect_two(node1, node2): if node1 == None or node2 == None: return node1.next = node2 connect_two(node1.left,node1.right) connect_two(node2.left,node2.right) connect_two(node1.right,node2.left) connect_two(root.left,root.right) return root LC114. Flatten Binary Tree to Linked List Given the root of a binary tree, flatten the tree into a \u0026#34;linked list\u0026#34;: The \u0026#34;linked list\u0026#34; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The \u0026#34;linked list\u0026#34; should be in the same order as a pre-order traversal of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0] class Solution(object): def flatten(self, root): if root == None: return self.flatten(root.left) self.flatten(root.right) right = root.right root.right = root.left root.left = None while root.right: root = root.right root.right = right LC144. Binary Tree Preorder Traversal Given the root of a binary tree, return the preorder traversal of its nodes\u0026#39; values. Example 1: Input: root = [1,null,2,3] Output: [1,2,3] Example 2: Input: root = [] Output: [] Example 3: Input: root = [1] Output: [1] class Solution(object): def preorderTraversal(self, root): if root == None: return [] nums = [root.val] nums += self.preorderTraversal(root.left) nums += self.preorderTraversal(root.right) return nums LC226. Invert Binary Tree Given the root of a binary tree, invert the tree, and return its root. Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3: Input: root = [] Output: [] class Solution(object): def invertTree(self, root): if root == None: return None right = root.right root.right = root.left root.left = right self.invertTree(root.left) self.invertTree(root.right) return root LC297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] class Codec: def serialize(self, root): if root == None: return \u0026#34;*\u0026#34; return str(root.val) + \u0026#34;,\u0026#34; + self.serialize(root.left) + \u0026#34;,\u0026#34; + self.serialize(root.right) def deserialize(self, data): data = data.split(\u0026#34;,\u0026#34;) def formTree(): num = data.pop(0) if num == \u0026#34;*\u0026#34;: return None root = TreeNode(int(num)) root.left = formTree() root.right = formTree() return root return formTree() LC543. Diameter of Binary Tree Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: Input: root = [1,2] Output: 1 class Solution(object): def diameterOfBinaryTree(self, root): max_d = [0] def dfs(root): if root is None: return 0 left_height = dfs(root.left) right_height = dfs(root.right) result = 1 + max(left_height, right_height) max_d[0] = max(max_d[0], left_height + right_height) return result dfs(root) return max_d[0] ","permalink":"https://zhengshutao.github.io/posts/lc_tree/","summary":"LC104. Maximum Depth of Binary Tree Given the root of a binary tree, return its maximum depth. A binary tree\u0026#39;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 class Solution(object): def maxDepth(self, root): if root == None: return 0 else: return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right)) LC116. Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the","title":"LeetCode - Tree"},{"content":"Projects Anti-Chess (Python, Git) Developed a Chess game using Python, utilizing object-oriented design techniques for implementation. Implemented the Minimax algorithm with Alpha-Beta Pruning, resulting in a win rate of 85% against classmates. Incorporated various design patterns, such as abstract classes, to mimic various Chess-gaming functionalities and improve the overall game experience. Collaborated with teammates through constant communication and code reviews to deliver a high-quality project on time. Text Adventure Game (Python, Git) Developed a captivating text-based adventure game with various challenges and choices for players. Utilized file input and output to enable save functionality, allowing players to pick up where they left off and continue their journey at a later time. Employed object-oriented programming concepts for a structured and organized approach to development. Escape From The Maze Game (C, Git) Utilized my knowledge of the right-hand rule wall follower algorithm to implement path-finding ","permalink":"https://zhengshutao.github.io/posts/ug_project/","summary":"Projects Anti-Chess (Python, Git) Developed a Chess game using Python, utilizing object-oriented design techniques for implementation. Implemented the Minimax algorithm with Alpha-Beta Pruning, resulting in a win rate of 85% against classmates. Incorporated various design patterns, such as abstract classes, to mimic various Chess-gaming functionalities and improve the overall game experience. Collaborated with teammates through constant communication and code reviews to deliver a high-quality project on time. Text Adventure Game (Python, Git) Developed a captivating text-based adventure game with various challenges and choices for players. Utilized file input and output to enable save functionality, allowing players to pick up where they left off and continue their journey at a later time. Employed object-oriented programming concepts for a structured and organized approach to development. Escape From The Maze Game (C, Git) Utilized my knowledge of the right-hand rule wall follower algorithm","title":"Project"},{"content":"Undergrad Education University of Waterloo | Sept. 2018 - Present | Expected graduation in August 2023 Major \u0026amp; Minors Computational Mathematics Major Combinatorics and Optimization Minor Computing Minor Contact Information +1 (416) 801 - 5771 stzheng@uwaterloo.ca Qualifications Proficient in Python, C/C++, PHP, JavaScript/HTML/CSS/Node.js, Linux/Unix and R Indicated capacity to complete research, information management and reporting efficiently Strong knowledge of data structures, algorithms, Object-Oriented programming and multi-threaded programming through coursework and work experience. Experience Junior Software Engineer/Quality Assurance Engineer | AEC Daily Inc | Jan. 2023 - Apr. 2023 Conducted manual testing for a company website, utilizing a black box testing methodology to ensure functionality and identify potential issues. Collaborated with developers to implement solutions to identified issues and contributed to the development of new website features using PHP, Smarty, HTML, and CSS. Successfully identified and reported a high number of bugs and defects in web applications, contributing to the overall improvement of the product. Software Engineer | Lifion by ADP | May 2022 - Aug. 2022 Successfully redesigned and implemented new features on an internal flowchart application using Node.js, resulting in improved output information for users. Developed new logic operators for the internal flowchart application, increasing its functionality for users. Implemented integration testing using Jenkins, covering over 90% of the new functionality in the application. Quality Assurance Engineer | NetDragon Websoft Holdings Limited | Sept. 2020 - Aug. 2021 Developed an automated test system for ActivPanel by Promethean, an educational interactive display used in over 1 million classrooms worldwide. Developed a test workflow that supports more efficient test case management, automated risk assessment, and test reports generation. The system ensured three successful product launches. Projects Anti-Chess (Python, Git) Developed a Chess game using Python, utilizing object-oriented design techniques for implementation. Implemented the Minimax algorithm with Alpha-Beta Pruning, resulting in a win rate of 85% against classmates. Incorporated various design patterns, such as abstract classes, to mimic various Chess-gaming functionalities and improve the overall game experience. Collaborated with teammates through constant communication and code reviews to deliver a high-quality project on time. Text Adventure Game (Python, Git) Developed a captivating text-based adventure game with various challenges and choices for players. Utilized file input and output to enable save functionality, allowing players to pick up where they left off and continue their journey at a later time. Employed object-oriented programming concepts for a structured and organized approach to development. Escape From The Maze Game (C, Git) Utilized my knowledge of the right-hand rule wall follower algorithm to implement path-finding Relevant Courses Object-Oriented Software Development Algorithms(Binary search, Dynamic programming, Two pointers, Sliding Window, Hashing) Data Structures Data Management ","permalink":"https://zhengshutao.github.io/resume/","summary":"Undergrad Education University of Waterloo | Sept. 2018 - Present | Expected graduation in August 2023 Major \u0026amp; Minors Computational Mathematics Major Combinatorics and Optimization Minor Computing Minor Contact Information +1 (416) 801 - 5771 stzheng@uwaterloo.ca Qualifications Proficient in Python, C/C++, PHP, JavaScript/HTML/CSS/Node.js, Linux/Unix and R Indicated capacity to complete research, information management and reporting efficiently Strong knowledge of data structures, algorithms, Object-Oriented programming and multi-threaded programming through coursework and work experience. Experience Junior Software Engineer/Quality Assurance Engineer | AEC Daily Inc | Jan. 2023 - Apr. 2023 Conducted manual testing for a company website, utilizing a black box testing methodology to ensure functionality and identify potential issues. Collaborated with developers to implement solutions to identified issues and contributed to the development of new website features using PHP, Smarty, HTML, and CSS. Successfully identified and reported a high number of","title":"Resume"},{"content":"class Me: def __init__(self): self.name = \u0026#34;ShuTao Zheng\u0026#34; self.hometown = \u0026#34;FuZhou, FuJian, China\u0026#34; self.undergrad_school = \u0026#34;uWaterloo\u0026#34; self.graduation_time = 2023 self.curr_location = \u0026#34;Waterloo, ON, Canada\u0026#34; ","permalink":"https://zhengshutao.github.io/about/","summary":"class Me: def __init__(self): self.name = \u0026#34;ShuTao Zheng\u0026#34; self.hometown = \u0026#34;FuZhou, FuJian, China\u0026#34; self.undergrad_school = \u0026#34;uWaterloo\u0026#34; self.graduation_time = 2023 self.curr_location = \u0026#34;Waterloo, ON, Canada\u0026#34;","title":"üôãüèª‚Äç‚ôÇÔ∏èAbout"}]